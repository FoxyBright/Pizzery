//
// AppliedDiscountItem.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct AppliedDiscountItem: Codable, Hashable {

    public var discount: DiscountItem?
    /** Total discount sum given by the discount item for all order items. */
    public var discountSum: Double?
    /** map[guid]decimal. Discount sums given by the discount item for each order item (products, compounds, services and modifiers). Absence of some order item's id means zero discount for that item. */
    public var discountSumByOrderItemId: [String: AppliedDiscountItemDiscountSumByOrderItemIdValue]?
    /** Indicates that the discount was used to round off the order sum. Depending on the settings, rounding can be performed up or down for individual items as well as for the entire order. */
    public var isRounding: Bool?

    public init(discount: DiscountItem? = nil, discountSum: Double? = nil, discountSumByOrderItemId: [String: AppliedDiscountItemDiscountSumByOrderItemIdValue]? = nil, isRounding: Bool? = nil) {
        self.discount = discount
        self.discountSum = discountSum
        self.discountSumByOrderItemId = discountSumByOrderItemId
        self.isRounding = isRounding
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case discount = "Discount"
        case discountSum = "DiscountSum"
        case discountSumByOrderItemId = "DiscountSumByOrderItemId"
        case isRounding = "IsRounding"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(discount, forKey: .discount)
        try container.encodeIfPresent(discountSum, forKey: .discountSum)
        try container.encodeIfPresent(discountSumByOrderItemId, forKey: .discountSumByOrderItemId)
        try container.encodeIfPresent(isRounding, forKey: .isRounding)
    }
}

