//
// IikoOrder.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct IikoOrder: Codable, Hashable {

    public var id: UUID?
    /** Subtotal, sum of all not deleted order items with included vat, but without excluded vat and discounts. */
    public var fullSum: Double?
    /** Total sum to be paid, sum of all not deleted order items with discounts and both included and excluded vat. */
    public var resultSum: Double?
    /** Discount items that have been added to the order. */
    public var discounts: [DiscountItem]?
    /** The result of applying discount items from Discounts. Discount items that don't affect the order, aren't included into this collection. */
    public var appliedDiscounts: [AppliedDiscountItem]?
    /** The result of applying payment items from Payments processed or fiscalized as discounts. */
    public var paymentDiscounts: [AppliedDiscountItem]?
    public var customerIds: [UUID]?
    public var guests: [Guest]?
    public var items: [OrderItem]?
    /** List of items which were deleted before printing. */
    public var removedItems: AnyCodable?
    public var payments: [PaymentItem]?
    public var donations: [PaymentItem]?
    /** \\ 0 - New. Newly created order. This status corresponds to lifetime from creation to ready-to-pay state. 1 - Bill. Bill cheque printed order. This status corresponds to lifetime between billing and payment. 2 - Closed. Paid order. 3 - Deleted. Deleted order. */
    public var status: Int?
    public var openTime: Date?
    /** Gets the bill cheque print time of the current order. */
    public var billTime: Date?
    /** Gets the payment time of the current order. */
    public var closeTime: Date?
    public var repeatBillNumber: Int?
    /** Fiscal cheque numbers. */
    public var fiscalChequeNumbers: [Int]?
    public var number: Int?
    public var tables: [Table]?
    public var waiter: Waiter?
    /** Gets the user closed the current order. */
    public var cashier: AnyCodable?
    /** Reserve / banquet related to the order. */
    public var reserve: AnyCodable?
    public var isBanquetOrder: Bool?
    public var isFastFoodOrder: Bool?
    /** Sum of all processed payment items in order. */
    public var processedPaymentsSum: Double?
    /** Gets estimated guests count, that is greater than or equal to added guests count. When single order is used to serve many people and handling each of them as a separate guest may be inconvenient, this property will indicate estimated guests count while guests collection will contain as many guests as needed for waiters. */
    public var estimatedGuestsCount: Int?
    public var orderType: OrderType?
    /** Optional marker used to specify order origin. This property contains either null or name of the source order was received from. Specifying origin allows to analyse efficiency of external order sources such as different web-sites, mobile applications and so on. */
    public var originName: String?
    /** Order comment. */
    public var comment: String?
    /** Time, which determines the price of products. By default time is taken from items print time. */
    public var pricingTime: Date?
    public var combos: [OrderCombo]?
    public var iikoCard51Info: IikoCardInfo?
    /** Whether order was prepaid. Any processed or deleted prepay. */
    public var wasPrepaid: Bool?
    /** The flag specifies that this order should be cooked out-of-order at kitchen. All orders which have this flag set on will appear above other orders at the kitchen display. Both groups (top priority and non-top priority) will be sorted separately using usual sorting logic (custom cooking priority, then default built-in criterions. Default value is false. */
    public var isTopCookingPriority: Bool?
    /** Specifies a custom cooking priority. While the application provides built-in prioritization logic for orders based on timing, dish courses, etc., you can override it and enforce custom cooking order based on your external logic. Ideally, all dishes should be cooked timely, but in case of concurrency when kitchen is high-loaded, you have to decide which orders are more important and should be cooked in the first place and which orders are allowed to be delayed. Higher priority values mean that the order, its serve groups and dishes will appear at the kitchen display earlier. Default value is zero. Both positive and negative values are allowed for raising and lowering the priority correspondingly. Orders with the same cooking priority will be sorted using default built-in logic. */
    public var cookingPriority: Int?
    public var priceCategory: PriceCategory?
    /** Optional marker used to specify that the order is a tab. This property contains name of the tab if the order is marked as tab, otherwise null. */
    public var tabName: String?
    /** Source order's identifier this order copied from during storno operation. null if the order has never storned. */
    public var stornedOrderId: UUID?
    /** Id of the terminal (ITerminal) that last changed the order. */
    public var lastChangedTerminalId: UUID?
    /** Optional order number in the external system. This can be used to match the external order to the iiko one. This property contains either null or number of the source order was received from. Specifying origin order number allows to analyse efficiency of external order sources such as different web-sites, mobile applications and so on. */
    public var externalNumber: String?
    /** The Id of the original order, if the current order is the result of a split. */
    public var parentOrderId: UUID?
    /** Group order id, if current order is an additional order. */
    public var groupOrderId: UUID?
    public var chequeAdditionalInfo: ChequeAdditionalInfo?
    /** Incremental version of the entity. (как я понял версионность объекта) */
    public var revision: Int?

    public init(id: UUID? = nil, fullSum: Double? = nil, resultSum: Double? = nil, discounts: [DiscountItem]? = nil, appliedDiscounts: [AppliedDiscountItem]? = nil, paymentDiscounts: [AppliedDiscountItem]? = nil, customerIds: [UUID]? = nil, guests: [Guest]? = nil, items: [OrderItem]? = nil, removedItems: AnyCodable? = nil, payments: [PaymentItem]? = nil, donations: [PaymentItem]? = nil, status: Int? = nil, openTime: Date? = nil, billTime: Date? = nil, closeTime: Date? = nil, repeatBillNumber: Int? = nil, fiscalChequeNumbers: [Int]? = nil, number: Int? = nil, tables: [Table]? = nil, waiter: Waiter? = nil, cashier: AnyCodable? = nil, reserve: AnyCodable? = nil, isBanquetOrder: Bool? = nil, isFastFoodOrder: Bool? = nil, processedPaymentsSum: Double? = nil, estimatedGuestsCount: Int? = nil, orderType: OrderType? = nil, originName: String? = nil, comment: String? = nil, pricingTime: Date? = nil, combos: [OrderCombo]? = nil, iikoCard51Info: IikoCardInfo? = nil, wasPrepaid: Bool? = nil, isTopCookingPriority: Bool? = nil, cookingPriority: Int? = nil, priceCategory: PriceCategory? = nil, tabName: String? = nil, stornedOrderId: UUID? = nil, lastChangedTerminalId: UUID? = nil, externalNumber: String? = nil, parentOrderId: UUID? = nil, groupOrderId: UUID? = nil, chequeAdditionalInfo: ChequeAdditionalInfo? = nil, revision: Int? = nil) {
        self.id = id
        self.fullSum = fullSum
        self.resultSum = resultSum
        self.discounts = discounts
        self.appliedDiscounts = appliedDiscounts
        self.paymentDiscounts = paymentDiscounts
        self.customerIds = customerIds
        self.guests = guests
        self.items = items
        self.removedItems = removedItems
        self.payments = payments
        self.donations = donations
        self.status = status
        self.openTime = openTime
        self.billTime = billTime
        self.closeTime = closeTime
        self.repeatBillNumber = repeatBillNumber
        self.fiscalChequeNumbers = fiscalChequeNumbers
        self.number = number
        self.tables = tables
        self.waiter = waiter
        self.cashier = cashier
        self.reserve = reserve
        self.isBanquetOrder = isBanquetOrder
        self.isFastFoodOrder = isFastFoodOrder
        self.processedPaymentsSum = processedPaymentsSum
        self.estimatedGuestsCount = estimatedGuestsCount
        self.orderType = orderType
        self.originName = originName
        self.comment = comment
        self.pricingTime = pricingTime
        self.combos = combos
        self.iikoCard51Info = iikoCard51Info
        self.wasPrepaid = wasPrepaid
        self.isTopCookingPriority = isTopCookingPriority
        self.cookingPriority = cookingPriority
        self.priceCategory = priceCategory
        self.tabName = tabName
        self.stornedOrderId = stornedOrderId
        self.lastChangedTerminalId = lastChangedTerminalId
        self.externalNumber = externalNumber
        self.parentOrderId = parentOrderId
        self.groupOrderId = groupOrderId
        self.chequeAdditionalInfo = chequeAdditionalInfo
        self.revision = revision
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id = "Id"
        case fullSum = "FullSum"
        case resultSum = "ResultSum"
        case discounts = "Discounts"
        case appliedDiscounts = "AppliedDiscounts"
        case paymentDiscounts = "PaymentDiscounts"
        case customerIds = "CustomerIds"
        case guests = "Guests"
        case items = "Items"
        case removedItems = "RemovedItems"
        case payments = "Payments"
        case donations = "Donations"
        case status = "Status"
        case openTime = "OpenTime"
        case billTime = "BillTime"
        case closeTime = "CloseTime"
        case repeatBillNumber = "RepeatBillNumber"
        case fiscalChequeNumbers = "FiscalChequeNumbers"
        case number = "Number"
        case tables = "Tables"
        case waiter = "Waiter"
        case cashier = "Cashier"
        case reserve = "Reserve"
        case isBanquetOrder = "IsBanquetOrder"
        case isFastFoodOrder = "IsFastFoodOrder"
        case processedPaymentsSum = "ProcessedPaymentsSum"
        case estimatedGuestsCount = "EstimatedGuestsCount"
        case orderType = "OrderType"
        case originName = "OriginName"
        case comment = "Comment"
        case pricingTime = "PricingTime"
        case combos = "Combos"
        case iikoCard51Info = "IikoCard51Info"
        case wasPrepaid = "WasPrepaid"
        case isTopCookingPriority = "IsTopCookingPriority"
        case cookingPriority = "CookingPriority"
        case priceCategory = "PriceCategory"
        case tabName = "TabName"
        case stornedOrderId = "StornedOrderId"
        case lastChangedTerminalId = "LastChangedTerminalId"
        case externalNumber = "ExternalNumber"
        case parentOrderId = "ParentOrderId"
        case groupOrderId = "GroupOrderId"
        case chequeAdditionalInfo = "ChequeAdditionalInfo"
        case revision = "Revision"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(fullSum, forKey: .fullSum)
        try container.encodeIfPresent(resultSum, forKey: .resultSum)
        try container.encodeIfPresent(discounts, forKey: .discounts)
        try container.encodeIfPresent(appliedDiscounts, forKey: .appliedDiscounts)
        try container.encodeIfPresent(paymentDiscounts, forKey: .paymentDiscounts)
        try container.encodeIfPresent(customerIds, forKey: .customerIds)
        try container.encodeIfPresent(guests, forKey: .guests)
        try container.encodeIfPresent(items, forKey: .items)
        try container.encodeIfPresent(removedItems, forKey: .removedItems)
        try container.encodeIfPresent(payments, forKey: .payments)
        try container.encodeIfPresent(donations, forKey: .donations)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(openTime, forKey: .openTime)
        try container.encodeIfPresent(billTime, forKey: .billTime)
        try container.encodeIfPresent(closeTime, forKey: .closeTime)
        try container.encodeIfPresent(repeatBillNumber, forKey: .repeatBillNumber)
        try container.encodeIfPresent(fiscalChequeNumbers, forKey: .fiscalChequeNumbers)
        try container.encodeIfPresent(number, forKey: .number)
        try container.encodeIfPresent(tables, forKey: .tables)
        try container.encodeIfPresent(waiter, forKey: .waiter)
        try container.encodeIfPresent(cashier, forKey: .cashier)
        try container.encodeIfPresent(reserve, forKey: .reserve)
        try container.encodeIfPresent(isBanquetOrder, forKey: .isBanquetOrder)
        try container.encodeIfPresent(isFastFoodOrder, forKey: .isFastFoodOrder)
        try container.encodeIfPresent(processedPaymentsSum, forKey: .processedPaymentsSum)
        try container.encodeIfPresent(estimatedGuestsCount, forKey: .estimatedGuestsCount)
        try container.encodeIfPresent(orderType, forKey: .orderType)
        try container.encodeIfPresent(originName, forKey: .originName)
        try container.encodeIfPresent(comment, forKey: .comment)
        try container.encodeIfPresent(pricingTime, forKey: .pricingTime)
        try container.encodeIfPresent(combos, forKey: .combos)
        try container.encodeIfPresent(iikoCard51Info, forKey: .iikoCard51Info)
        try container.encodeIfPresent(wasPrepaid, forKey: .wasPrepaid)
        try container.encodeIfPresent(isTopCookingPriority, forKey: .isTopCookingPriority)
        try container.encodeIfPresent(cookingPriority, forKey: .cookingPriority)
        try container.encodeIfPresent(priceCategory, forKey: .priceCategory)
        try container.encodeIfPresent(tabName, forKey: .tabName)
        try container.encodeIfPresent(stornedOrderId, forKey: .stornedOrderId)
        try container.encodeIfPresent(lastChangedTerminalId, forKey: .lastChangedTerminalId)
        try container.encodeIfPresent(externalNumber, forKey: .externalNumber)
        try container.encodeIfPresent(parentOrderId, forKey: .parentOrderId)
        try container.encodeIfPresent(groupOrderId, forKey: .groupOrderId)
        try container.encodeIfPresent(chequeAdditionalInfo, forKey: .chequeAdditionalInfo)
        try container.encodeIfPresent(revision, forKey: .revision)
    }
}

